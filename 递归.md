递归是一种非常高效、简洁的编码技巧，它通过一个函数在执行过程中一次或多次调用其本身，或通过一种数据结构在其表示中依赖于相同类型的结构更小的实例来实现。

### 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解。
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件。

### 如何编写递归代码

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

### 递归的优缺点

+ 优点：代码的表达力很强，写起来简洁。
+ 缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。

### 递归常见问题及解决方案

+ 堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
+ 重复计算：记忆化（memoization）可以用来避免这个问题。

### 尾递归

当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。 当函数的调用层数非常多时，调用栈会消耗不少内存，甚至会撑爆内存空间，造成程序严重卡顿或意外崩溃。尾递归的调用栈则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。

### LeetCode

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

>F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

给定 N，计算 F(N)。

示例 ：

>输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.

>输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.

>输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.


##### 解法1：

```python
class Solution:
    def fib(self, N: int) -> int:
        if N <= 1:
            return N
        else:
            return self.fib(N - 1) + self.fib(N - 2)
```

使用递归依次求解，此方法效率较低，重复性求值较为严重。

>F(3) = F(2) + F(1) = F(1) + F(0) + F(1) = 1 + 0 + 1 = 2

时间复杂度：O(2^N)，这是计算斐波那契数最慢的方法。因为它需要指数的时间。
空间复杂度：O(N)，在堆栈中我们需要与 N 成正比的空间大小。

##### 解法2：

```python
class Solution:
    def fib(self, N: int) -> int:
        cur, prev = self.f(N)
        return cur

    def f(self, N: int) -> Tuple[int, int]:
        if N <= 1:
            return N, 0
        else:
            cur, prev = self.f(N - 1)
            return cur + prev, cur
```

通过使用记忆化的方法，记录求过的值。提高效率。

时间复杂度：O(N)。
空间复杂度：O(N)，内存中使用的堆栈大小。

#### [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

示例:

>输入： S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

>输入：S = "3z4"
输出： ["3z4", "3Z4"]

>输入：S = "12345"
输出：["12345"]

注意：

+ S的长度不超过12。
+ S仅由数字和字母组成。

##### 解法1：
```python
class Solution:

    def letterCasePermutation(self, S: str) -> List[str]:
        ans = []

        def dfs(S: List[str], i: int, n: int) -> None:
            if i == n:
                ans.append(''.join(S))
                return
            dfs(S, i + 1, n)
            if not S[i].isalpha(): return
            S[i] = S[i].swapcase() #交换大小写
            dfs(S, i + 1, n)

        dfs(list(S), 0, len(S))
        return ans
```

采用深度优先搜索，回溯所有的可能结果。

时间复杂度：O(N*2^N)。
空间复杂度：O(N*2^N)。